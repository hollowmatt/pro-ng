{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n0 && (module.exports = {\n  matchHas: null,\n  compileNonPath: null,\n  prepareDestination: null\n});\nfunction _export(target, all) {\n  for (var name in all) Object.defineProperty(target, name, {\n    enumerable: true,\n    get: all[name]\n  });\n}\n_export(exports, {\n  matchHas: function () {\n    return matchHas;\n  },\n  compileNonPath: function () {\n    return compileNonPath;\n  },\n  prepareDestination: function () {\n    return prepareDestination;\n  }\n});\nconst _pathtoregexp = require(\"next/dist/compiled/path-to-regexp\");\nconst _escaperegexp = require(\"../../escape-regexp\");\nconst _parseurl = require(\"./parse-url\");\nconst _interceptionroutes = require(\"../../../../server/future/helpers/interception-routes\");\nconst _approuterheaders = require(\"../../../../client/components/app-router-headers\");\n/**\n * Ensure only a-zA-Z are used for param names for proper interpolating\n * with path-to-regexp\n */\nfunction getSafeParamName(paramName) {\n  let newParamName = \"\";\n  for (let i = 0; i < paramName.length; i++) {\n    const charCode = paramName.charCodeAt(i);\n    if (charCode > 64 && charCode < 91 ||\n    // A-Z\n    charCode > 96 && charCode < 123 // a-z\n    ) {\n      newParamName += paramName[i];\n    }\n  }\n  return newParamName;\n}\nfunction escapeSegment(str, segmentName) {\n  return str.replace(new RegExp(\":\" + (0, _escaperegexp.escapeStringRegexp)(segmentName), \"g\"), \"__ESC_COLON_\" + segmentName);\n}\nfunction unescapeSegments(str) {\n  return str.replace(/__ESC_COLON_/gi, \":\");\n}\nfunction matchHas(req, query, has, missing) {\n  if (has === void 0) has = [];\n  if (missing === void 0) missing = [];\n  const params = {};\n  const hasMatch = hasItem => {\n    let value;\n    let key = hasItem.key;\n    switch (hasItem.type) {\n      case \"header\":\n        {\n          key = key.toLowerCase();\n          value = req.headers[key];\n          break;\n        }\n      case \"cookie\":\n        {\n          value = req.cookies[hasItem.key];\n          break;\n        }\n      case \"query\":\n        {\n          value = query[key];\n          break;\n        }\n      case \"host\":\n        {\n          const {\n            host\n          } = (req == null ? void 0 : req.headers) || {};\n          // remove port from host if present\n          const hostname = host == null ? void 0 : host.split(\":\")[0].toLowerCase();\n          value = hostname;\n          break;\n        }\n      default:\n        {\n          break;\n        }\n    }\n    if (!hasItem.value && value) {\n      params[getSafeParamName(key)] = value;\n      return true;\n    } else if (value) {\n      const matcher = new RegExp(\"^\" + hasItem.value + \"$\");\n      const matches = Array.isArray(value) ? value.slice(-1)[0].match(matcher) : value.match(matcher);\n      if (matches) {\n        if (Array.isArray(matches)) {\n          if (matches.groups) {\n            Object.keys(matches.groups).forEach(groupKey => {\n              params[groupKey] = matches.groups[groupKey];\n            });\n          } else if (hasItem.type === \"host\" && matches[0]) {\n            params.host = matches[0];\n          }\n        }\n        return true;\n      }\n    }\n    return false;\n  };\n  const allMatch = has.every(item => hasMatch(item)) && !missing.some(item => hasMatch(item));\n  if (allMatch) {\n    return params;\n  }\n  return false;\n}\nfunction compileNonPath(value, params) {\n  if (!value.includes(\":\")) {\n    return value;\n  }\n  for (const key of Object.keys(params)) {\n    if (value.includes(\":\" + key)) {\n      value = value.replace(new RegExp(\":\" + key + \"\\\\*\", \"g\"), \":\" + key + \"--ESCAPED_PARAM_ASTERISKS\").replace(new RegExp(\":\" + key + \"\\\\?\", \"g\"), \":\" + key + \"--ESCAPED_PARAM_QUESTION\").replace(new RegExp(\":\" + key + \"\\\\+\", \"g\"), \":\" + key + \"--ESCAPED_PARAM_PLUS\").replace(new RegExp(\":\" + key + \"(?!\\\\w)\", \"g\"), \"--ESCAPED_PARAM_COLON\" + key);\n    }\n  }\n  value = value.replace(/(:|\\*|\\?|\\+|\\(|\\)|\\{|\\})/g, \"\\\\$1\").replace(/--ESCAPED_PARAM_PLUS/g, \"+\").replace(/--ESCAPED_PARAM_COLON/g, \":\").replace(/--ESCAPED_PARAM_QUESTION/g, \"?\").replace(/--ESCAPED_PARAM_ASTERISKS/g, \"*\");\n  // the value needs to start with a forward-slash to be compiled\n  // correctly\n  return (0, _pathtoregexp.compile)(\"/\" + value, {\n    validate: false\n  })(params).slice(1);\n}\nfunction prepareDestination(args) {\n  const query = Object.assign({}, args.query);\n  delete query.__nextLocale;\n  delete query.__nextDefaultLocale;\n  delete query.__nextDataReq;\n  delete query.__nextInferredLocaleFromDefault;\n  delete query[_approuterheaders.NEXT_RSC_UNION_QUERY];\n  let escapedDestination = args.destination;\n  for (const param of Object.keys({\n    ...args.params,\n    ...query\n  })) {\n    escapedDestination = escapeSegment(escapedDestination, param);\n  }\n  const parsedDestination = (0, _parseurl.parseUrl)(escapedDestination);\n  const destQuery = parsedDestination.query;\n  const destPath = unescapeSegments(\"\" + parsedDestination.pathname + (parsedDestination.hash || \"\"));\n  const destHostname = unescapeSegments(parsedDestination.hostname || \"\");\n  const destPathParamKeys = [];\n  const destHostnameParamKeys = [];\n  (0, _pathtoregexp.pathToRegexp)(destPath, destPathParamKeys);\n  (0, _pathtoregexp.pathToRegexp)(destHostname, destHostnameParamKeys);\n  const destParams = [];\n  destPathParamKeys.forEach(key => destParams.push(key.name));\n  destHostnameParamKeys.forEach(key => destParams.push(key.name));\n  const destPathCompiler = (0, _pathtoregexp.compile)(destPath,\n  // we don't validate while compiling the destination since we should\n  // have already validated before we got to this point and validating\n  // breaks compiling destinations with named pattern params from the source\n  // e.g. /something:hello(.*) -> /another/:hello is broken with validation\n  // since compile validation is meant for reversing and not for inserting\n  // params from a separate path-regex into another\n  {\n    validate: false\n  });\n  const destHostnameCompiler = (0, _pathtoregexp.compile)(destHostname, {\n    validate: false\n  });\n  // update any params in query values\n  for (const [key, strOrArray] of Object.entries(destQuery)) {\n    // the value needs to start with a forward-slash to be compiled\n    // correctly\n    if (Array.isArray(strOrArray)) {\n      destQuery[key] = strOrArray.map(value => compileNonPath(unescapeSegments(value), args.params));\n    } else if (typeof strOrArray === \"string\") {\n      destQuery[key] = compileNonPath(unescapeSegments(strOrArray), args.params);\n    }\n  }\n  // add path params to query if it's not a redirect and not\n  // already defined in destination query or path\n  let paramKeys = Object.keys(args.params).filter(name => name !== \"nextInternalLocale\");\n  if (args.appendParamsToQuery && !paramKeys.some(key => destParams.includes(key))) {\n    for (const key of paramKeys) {\n      if (!(key in destQuery)) {\n        destQuery[key] = args.params[key];\n      }\n    }\n  }\n  let newUrl;\n  // The compiler also that the interception route marker is an unnamed param, hence '0',\n  // so we need to add it to the params object.\n  if ((0, _interceptionroutes.isInterceptionRouteAppPath)(destPath)) {\n    for (const segment of destPath.split(\"/\")) {\n      const marker = _interceptionroutes.INTERCEPTION_ROUTE_MARKERS.find(m => segment.startsWith(m));\n      if (marker) {\n        args.params[\"0\"] = marker;\n        break;\n      }\n    }\n  }\n  try {\n    newUrl = destPathCompiler(args.params);\n    const [pathname, hash] = newUrl.split(\"#\");\n    parsedDestination.hostname = destHostnameCompiler(args.params);\n    parsedDestination.pathname = pathname;\n    parsedDestination.hash = \"\" + (hash ? \"#\" : \"\") + (hash || \"\");\n    delete parsedDestination.search;\n  } catch (err) {\n    if (err.message.match(/Expected .*? to not repeat, but got an array/)) {\n      throw new Error(\"To use a multi-match in the destination you must add `*` at the end of the param name to signify it should repeat. https://nextjs.org/docs/messages/invalid-multi-match\");\n    }\n    throw err;\n  }\n  // Query merge order lowest priority to highest\n  // 1. initial URL query values\n  // 2. path segment values\n  // 3. destination specified query values\n  parsedDestination.query = {\n    ...query,\n    ...parsedDestination.query\n  };\n  return {\n    newUrl,\n    destQuery,\n    parsedDestination\n  };\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","module","matchHas","compileNonPath","prepareDestination","_export","target","all","name","enumerable","get","_pathtoregexp","require","_escaperegexp","_parseurl","_interceptionroutes","_approuterheaders","getSafeParamName","paramName","newParamName","i","length","charCode","charCodeAt","escapeSegment","str","segmentName","replace","RegExp","escapeStringRegexp","unescapeSegments","req","query","has","missing","params","hasMatch","hasItem","key","type","toLowerCase","headers","cookies","host","hostname","split","matcher","matches","Array","isArray","slice","match","groups","keys","forEach","groupKey","allMatch","every","item","some","includes","compile","validate","args","assign","__nextLocale","__nextDefaultLocale","__nextDataReq","__nextInferredLocaleFromDefault","NEXT_RSC_UNION_QUERY","escapedDestination","destination","param","parsedDestination","parseUrl","destQuery","destPath","pathname","hash","destHostname","destPathParamKeys","destHostnameParamKeys","pathToRegexp","destParams","push","destPathCompiler","destHostnameCompiler","strOrArray","entries","map","paramKeys","filter","appendParamsToQuery","newUrl","isInterceptionRouteAppPath","segment","marker","INTERCEPTION_ROUTE_MARKERS","find","m","startsWith","search","err","message","Error"],"sources":["/Users/hollowmatt/node_modules/next/dist/shared/lib/router/utils/prepare-destination.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n0 && (module.exports = {\n    matchHas: null,\n    compileNonPath: null,\n    prepareDestination: null\n});\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    matchHas: function() {\n        return matchHas;\n    },\n    compileNonPath: function() {\n        return compileNonPath;\n    },\n    prepareDestination: function() {\n        return prepareDestination;\n    }\n});\nconst _pathtoregexp = require(\"next/dist/compiled/path-to-regexp\");\nconst _escaperegexp = require(\"../../escape-regexp\");\nconst _parseurl = require(\"./parse-url\");\nconst _interceptionroutes = require(\"../../../../server/future/helpers/interception-routes\");\nconst _approuterheaders = require(\"../../../../client/components/app-router-headers\");\n/**\n * Ensure only a-zA-Z are used for param names for proper interpolating\n * with path-to-regexp\n */ function getSafeParamName(paramName) {\n    let newParamName = \"\";\n    for(let i = 0; i < paramName.length; i++){\n        const charCode = paramName.charCodeAt(i);\n        if (charCode > 64 && charCode < 91 || // A-Z\n        charCode > 96 && charCode < 123 // a-z\n        ) {\n            newParamName += paramName[i];\n        }\n    }\n    return newParamName;\n}\nfunction escapeSegment(str, segmentName) {\n    return str.replace(new RegExp(\":\" + (0, _escaperegexp.escapeStringRegexp)(segmentName), \"g\"), \"__ESC_COLON_\" + segmentName);\n}\nfunction unescapeSegments(str) {\n    return str.replace(/__ESC_COLON_/gi, \":\");\n}\nfunction matchHas(req, query, has, missing) {\n    if (has === void 0) has = [];\n    if (missing === void 0) missing = [];\n    const params = {};\n    const hasMatch = (hasItem)=>{\n        let value;\n        let key = hasItem.key;\n        switch(hasItem.type){\n            case \"header\":\n                {\n                    key = key.toLowerCase();\n                    value = req.headers[key];\n                    break;\n                }\n            case \"cookie\":\n                {\n                    value = req.cookies[hasItem.key];\n                    break;\n                }\n            case \"query\":\n                {\n                    value = query[key];\n                    break;\n                }\n            case \"host\":\n                {\n                    const { host  } = (req == null ? void 0 : req.headers) || {};\n                    // remove port from host if present\n                    const hostname = host == null ? void 0 : host.split(\":\")[0].toLowerCase();\n                    value = hostname;\n                    break;\n                }\n            default:\n                {\n                    break;\n                }\n        }\n        if (!hasItem.value && value) {\n            params[getSafeParamName(key)] = value;\n            return true;\n        } else if (value) {\n            const matcher = new RegExp(\"^\" + hasItem.value + \"$\");\n            const matches = Array.isArray(value) ? value.slice(-1)[0].match(matcher) : value.match(matcher);\n            if (matches) {\n                if (Array.isArray(matches)) {\n                    if (matches.groups) {\n                        Object.keys(matches.groups).forEach((groupKey)=>{\n                            params[groupKey] = matches.groups[groupKey];\n                        });\n                    } else if (hasItem.type === \"host\" && matches[0]) {\n                        params.host = matches[0];\n                    }\n                }\n                return true;\n            }\n        }\n        return false;\n    };\n    const allMatch = has.every((item)=>hasMatch(item)) && !missing.some((item)=>hasMatch(item));\n    if (allMatch) {\n        return params;\n    }\n    return false;\n}\nfunction compileNonPath(value, params) {\n    if (!value.includes(\":\")) {\n        return value;\n    }\n    for (const key of Object.keys(params)){\n        if (value.includes(\":\" + key)) {\n            value = value.replace(new RegExp(\":\" + key + \"\\\\*\", \"g\"), \":\" + key + \"--ESCAPED_PARAM_ASTERISKS\").replace(new RegExp(\":\" + key + \"\\\\?\", \"g\"), \":\" + key + \"--ESCAPED_PARAM_QUESTION\").replace(new RegExp(\":\" + key + \"\\\\+\", \"g\"), \":\" + key + \"--ESCAPED_PARAM_PLUS\").replace(new RegExp(\":\" + key + \"(?!\\\\w)\", \"g\"), \"--ESCAPED_PARAM_COLON\" + key);\n        }\n    }\n    value = value.replace(/(:|\\*|\\?|\\+|\\(|\\)|\\{|\\})/g, \"\\\\$1\").replace(/--ESCAPED_PARAM_PLUS/g, \"+\").replace(/--ESCAPED_PARAM_COLON/g, \":\").replace(/--ESCAPED_PARAM_QUESTION/g, \"?\").replace(/--ESCAPED_PARAM_ASTERISKS/g, \"*\");\n    // the value needs to start with a forward-slash to be compiled\n    // correctly\n    return (0, _pathtoregexp.compile)(\"/\" + value, {\n        validate: false\n    })(params).slice(1);\n}\nfunction prepareDestination(args) {\n    const query = Object.assign({}, args.query);\n    delete query.__nextLocale;\n    delete query.__nextDefaultLocale;\n    delete query.__nextDataReq;\n    delete query.__nextInferredLocaleFromDefault;\n    delete query[_approuterheaders.NEXT_RSC_UNION_QUERY];\n    let escapedDestination = args.destination;\n    for (const param of Object.keys({\n        ...args.params,\n        ...query\n    })){\n        escapedDestination = escapeSegment(escapedDestination, param);\n    }\n    const parsedDestination = (0, _parseurl.parseUrl)(escapedDestination);\n    const destQuery = parsedDestination.query;\n    const destPath = unescapeSegments(\"\" + parsedDestination.pathname + (parsedDestination.hash || \"\"));\n    const destHostname = unescapeSegments(parsedDestination.hostname || \"\");\n    const destPathParamKeys = [];\n    const destHostnameParamKeys = [];\n    (0, _pathtoregexp.pathToRegexp)(destPath, destPathParamKeys);\n    (0, _pathtoregexp.pathToRegexp)(destHostname, destHostnameParamKeys);\n    const destParams = [];\n    destPathParamKeys.forEach((key)=>destParams.push(key.name));\n    destHostnameParamKeys.forEach((key)=>destParams.push(key.name));\n    const destPathCompiler = (0, _pathtoregexp.compile)(destPath, // we don't validate while compiling the destination since we should\n    // have already validated before we got to this point and validating\n    // breaks compiling destinations with named pattern params from the source\n    // e.g. /something:hello(.*) -> /another/:hello is broken with validation\n    // since compile validation is meant for reversing and not for inserting\n    // params from a separate path-regex into another\n    {\n        validate: false\n    });\n    const destHostnameCompiler = (0, _pathtoregexp.compile)(destHostname, {\n        validate: false\n    });\n    // update any params in query values\n    for (const [key, strOrArray] of Object.entries(destQuery)){\n        // the value needs to start with a forward-slash to be compiled\n        // correctly\n        if (Array.isArray(strOrArray)) {\n            destQuery[key] = strOrArray.map((value)=>compileNonPath(unescapeSegments(value), args.params));\n        } else if (typeof strOrArray === \"string\") {\n            destQuery[key] = compileNonPath(unescapeSegments(strOrArray), args.params);\n        }\n    }\n    // add path params to query if it's not a redirect and not\n    // already defined in destination query or path\n    let paramKeys = Object.keys(args.params).filter((name)=>name !== \"nextInternalLocale\");\n    if (args.appendParamsToQuery && !paramKeys.some((key)=>destParams.includes(key))) {\n        for (const key of paramKeys){\n            if (!(key in destQuery)) {\n                destQuery[key] = args.params[key];\n            }\n        }\n    }\n    let newUrl;\n    // The compiler also that the interception route marker is an unnamed param, hence '0',\n    // so we need to add it to the params object.\n    if ((0, _interceptionroutes.isInterceptionRouteAppPath)(destPath)) {\n        for (const segment of destPath.split(\"/\")){\n            const marker = _interceptionroutes.INTERCEPTION_ROUTE_MARKERS.find((m)=>segment.startsWith(m));\n            if (marker) {\n                args.params[\"0\"] = marker;\n                break;\n            }\n        }\n    }\n    try {\n        newUrl = destPathCompiler(args.params);\n        const [pathname, hash] = newUrl.split(\"#\");\n        parsedDestination.hostname = destHostnameCompiler(args.params);\n        parsedDestination.pathname = pathname;\n        parsedDestination.hash = \"\" + (hash ? \"#\" : \"\") + (hash || \"\");\n        delete parsedDestination.search;\n    } catch (err) {\n        if (err.message.match(/Expected .*? to not repeat, but got an array/)) {\n            throw new Error(\"To use a multi-match in the destination you must add `*` at the end of the param name to signify it should repeat. https://nextjs.org/docs/messages/invalid-multi-match\");\n        }\n        throw err;\n    }\n    // Query merge order lowest priority to highest\n    // 1. initial URL query values\n    // 2. path segment values\n    // 3. destination specified query values\n    parsedDestination.query = {\n        ...query,\n        ...parsedDestination.query\n    };\n    return {\n        newUrl,\n        destQuery,\n        parsedDestination\n    };\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}
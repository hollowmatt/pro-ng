{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"resolveHref\", {\n  enumerable: true,\n  get: function () {\n    return resolveHref;\n  }\n});\nconst _querystring = require(\"./querystring\");\nconst _formaturl = require(\"./format-url\");\nconst _omit = require(\"./omit\");\nconst _utils = require(\"../../utils\");\nconst _normalizetrailingslash = require(\"../../../../client/normalize-trailing-slash\");\nconst _islocalurl = require(\"./is-local-url\");\nconst _isdynamic = require(\"./is-dynamic\");\nconst _interpolateas = require(\"./interpolate-as\");\nfunction resolveHref(router, href, resolveAs) {\n  // we use a dummy base url for relative urls\n  let base;\n  let urlAsString = typeof href === \"string\" ? href : (0, _formaturl.formatWithValidation)(href);\n  // repeated slashes and backslashes in the URL are considered\n  // invalid and will never match a Next.js page/file\n  const urlProtoMatch = urlAsString.match(/^[a-zA-Z]{1,}:\\/\\//);\n  const urlAsStringNoProto = urlProtoMatch ? urlAsString.slice(urlProtoMatch[0].length) : urlAsString;\n  const urlParts = urlAsStringNoProto.split(\"?\");\n  if ((urlParts[0] || \"\").match(/(\\/\\/|\\\\)/)) {\n    console.error(\"Invalid href '\" + urlAsString + \"' passed to next/router in page: '\" + router.pathname + \"'. Repeated forward-slashes (//) or backslashes \\\\ are not valid in the href.\");\n    const normalizedUrl = (0, _utils.normalizeRepeatedSlashes)(urlAsStringNoProto);\n    urlAsString = (urlProtoMatch ? urlProtoMatch[0] : \"\") + normalizedUrl;\n  }\n  // Return because it cannot be routed by the Next.js router\n  if (!(0, _islocalurl.isLocalURL)(urlAsString)) {\n    return resolveAs ? [urlAsString] : urlAsString;\n  }\n  try {\n    base = new URL(urlAsString.startsWith(\"#\") ? router.asPath : router.pathname, \"http://n\");\n  } catch (_) {\n    // fallback to / for invalid asPath values e.g. //\n    base = new URL(\"/\", \"http://n\");\n  }\n  try {\n    const finalUrl = new URL(urlAsString, base);\n    finalUrl.pathname = (0, _normalizetrailingslash.normalizePathTrailingSlash)(finalUrl.pathname);\n    let interpolatedAs = \"\";\n    if ((0, _isdynamic.isDynamicRoute)(finalUrl.pathname) && finalUrl.searchParams && resolveAs) {\n      const query = (0, _querystring.searchParamsToUrlQuery)(finalUrl.searchParams);\n      const {\n        result,\n        params\n      } = (0, _interpolateas.interpolateAs)(finalUrl.pathname, finalUrl.pathname, query);\n      if (result) {\n        interpolatedAs = (0, _formaturl.formatWithValidation)({\n          pathname: result,\n          hash: finalUrl.hash,\n          query: (0, _omit.omit)(query, params)\n        });\n      }\n    }\n    // if the origin didn't change, it means we received a relative href\n    const resolvedHref = finalUrl.origin === base.origin ? finalUrl.href.slice(finalUrl.origin.length) : finalUrl.href;\n    return resolveAs ? [resolvedHref, interpolatedAs || resolvedHref] : resolvedHref;\n  } catch (_) {\n    return resolveAs ? [urlAsString] : urlAsString;\n  }\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","enumerable","get","resolveHref","_querystring","require","_formaturl","_omit","_utils","_normalizetrailingslash","_islocalurl","_isdynamic","_interpolateas","router","href","resolveAs","base","urlAsString","formatWithValidation","urlProtoMatch","match","urlAsStringNoProto","slice","length","urlParts","split","console","error","pathname","normalizedUrl","normalizeRepeatedSlashes","isLocalURL","URL","startsWith","asPath","_","finalUrl","normalizePathTrailingSlash","interpolatedAs","isDynamicRoute","searchParams","query","searchParamsToUrlQuery","result","params","interpolateAs","hash","omit","resolvedHref","origin"],"sources":["/Users/hollowmatt/node_modules/next/dist/shared/lib/router/utils/resolve-href.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nObject.defineProperty(exports, \"resolveHref\", {\n    enumerable: true,\n    get: function() {\n        return resolveHref;\n    }\n});\nconst _querystring = require(\"./querystring\");\nconst _formaturl = require(\"./format-url\");\nconst _omit = require(\"./omit\");\nconst _utils = require(\"../../utils\");\nconst _normalizetrailingslash = require(\"../../../../client/normalize-trailing-slash\");\nconst _islocalurl = require(\"./is-local-url\");\nconst _isdynamic = require(\"./is-dynamic\");\nconst _interpolateas = require(\"./interpolate-as\");\nfunction resolveHref(router, href, resolveAs) {\n    // we use a dummy base url for relative urls\n    let base;\n    let urlAsString = typeof href === \"string\" ? href : (0, _formaturl.formatWithValidation)(href);\n    // repeated slashes and backslashes in the URL are considered\n    // invalid and will never match a Next.js page/file\n    const urlProtoMatch = urlAsString.match(/^[a-zA-Z]{1,}:\\/\\//);\n    const urlAsStringNoProto = urlProtoMatch ? urlAsString.slice(urlProtoMatch[0].length) : urlAsString;\n    const urlParts = urlAsStringNoProto.split(\"?\");\n    if ((urlParts[0] || \"\").match(/(\\/\\/|\\\\)/)) {\n        console.error(\"Invalid href '\" + urlAsString + \"' passed to next/router in page: '\" + router.pathname + \"'. Repeated forward-slashes (//) or backslashes \\\\ are not valid in the href.\");\n        const normalizedUrl = (0, _utils.normalizeRepeatedSlashes)(urlAsStringNoProto);\n        urlAsString = (urlProtoMatch ? urlProtoMatch[0] : \"\") + normalizedUrl;\n    }\n    // Return because it cannot be routed by the Next.js router\n    if (!(0, _islocalurl.isLocalURL)(urlAsString)) {\n        return resolveAs ? [\n            urlAsString\n        ] : urlAsString;\n    }\n    try {\n        base = new URL(urlAsString.startsWith(\"#\") ? router.asPath : router.pathname, \"http://n\");\n    } catch (_) {\n        // fallback to / for invalid asPath values e.g. //\n        base = new URL(\"/\", \"http://n\");\n    }\n    try {\n        const finalUrl = new URL(urlAsString, base);\n        finalUrl.pathname = (0, _normalizetrailingslash.normalizePathTrailingSlash)(finalUrl.pathname);\n        let interpolatedAs = \"\";\n        if ((0, _isdynamic.isDynamicRoute)(finalUrl.pathname) && finalUrl.searchParams && resolveAs) {\n            const query = (0, _querystring.searchParamsToUrlQuery)(finalUrl.searchParams);\n            const { result , params  } = (0, _interpolateas.interpolateAs)(finalUrl.pathname, finalUrl.pathname, query);\n            if (result) {\n                interpolatedAs = (0, _formaturl.formatWithValidation)({\n                    pathname: result,\n                    hash: finalUrl.hash,\n                    query: (0, _omit.omit)(query, params)\n                });\n            }\n        }\n        // if the origin didn't change, it means we received a relative href\n        const resolvedHref = finalUrl.origin === base.origin ? finalUrl.href.slice(finalUrl.origin.length) : finalUrl.href;\n        return resolveAs ? [\n            resolvedHref,\n            interpolatedAs || resolvedHref\n        ] : resolvedHref;\n    } catch (_) {\n        return resolveAs ? [\n            urlAsString\n        ] : urlAsString;\n    }\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}